
server <- function (input, output, session) {
  
  output$ui2 <- renderUI ({
#     print (sprintf ('entered ui2 with plot %d', input$plot))
#     print (chp[[input$plot]]);print (slp[[input$plot]])
    PVar <<- slp[[input$plot]]
    selectInput ('PlotVar', label='variables', selectize=FALSE, multiple=TRUE,
                 choices=chp[[input$plot]], selected=slp[[input$plot]], size=10)
  })
  
  observe ({
    print ('entered observe for PlotVar')
    print (sprintf ('PVar is %s', PVar))
    # print (input$PlotVar)
    if (any (!(PVar %in% names (data ())))) {
      print ('need new data')
      reac$newdata <- TRUE
    }
    jp <- psq[1, input$plot]
    print (sprintf ('redefined global VRPlot[[%d]]', jp))
    # PVar <<- input$PlotVar
    VRPlot[[jp]] <<- PVar  ##input$PlotVar
  })
  
  observe({
    vp <- switch (input$Rplot,
                  'track' = 1,
                  'temperature' = 3,
                  'humidity' = 5,
                  'pressure' = 9,
                  'wind' = 13,
                  'radiation' = 20,
                  'particles' = 21,
                  'skew-T' = 26,
                  'potential T' = 28,
                  'CDP' = 29,
                  'UHSAS/PCASP' = 33,
                  '2DC' = 37,
                  'air chemistry' = 49
    )
    updateNumericInput (session, 'plot', value=vp)
  })
  
  reac <- reactiveValues (newdata=FALSE)
  
  observeEvent (input$reconfigure, saveConfig (), handler.env=.GlobalEnv)
  
  VRP <- reactive ({
    print ('entered VRP')
    if (input$Project != Project) {
      Project <<- Project <- input$Project
      source ('Configuration.R', local=FALSE)
    }
  })
  
  data <- reactive({
    print ('entered data')
    Project <<- Project <- input$Project
    reac$newdata
    reac$newdata <- FALSE
    VarList <- vector()
    # VRPlot <- VRP ()
    for (i in 1:length(VRPlot)) {
      for (j in 1:length (VRPlot[[i]])) {
        VarList <- c(VarList, VRPlot[[i]][j])
      }
    }
    ## these are needed for translation to new cal coefficients
    ## VarList <- c(VarList, "RTH1", "RTH2", "RTF1")
    fname <<- sprintf ('%s%s/%srf%02d.nc', DataDirectory (), input$Project, 
                       input$Project, input$Flight)
    getNetCDF (fname, VarList)
  })
  
  
  output$M1 <- renderText ({
    switch (psq[1, input$plot],
            'Track Plot and z-t',
            'Track Plot and z-t',
            'Temperature history',
            'Temp. scatterplots',
            'Humidity plots',
            'pressure',
            'dynamic p/TAS/M',
            'total pressure',
            'wind',
            'Schuler/comp f.',
            'AKRD/SSRD',
            'IRU comparison',
            'more IRU',
            'radiation',
            'concentrations',
            'dbar/lwc/housek.',
            'skew-T diagram',
            'plot not available',
            'potential T',
            'CDP',
            'UHSAS/PCASP',
            '2DC (1D sizes)', 
            'air chemistry'
    )
  })
  
  output$ui <- renderUI({
    print ('setting time')
    sliderInput("times", label=NA,
                min=data()$Time[1], max=data()$Time[nrow(data())], 
                #                 max=as.POSIXct (86400+10*3600, origin='2012-05-29', tz='UTC'),
                value=c(data()$Time[1], data()$Time[nrow(data())]),
                #                 value=c(as.POSIXct(70000, origin='2012-05-29', tz='UTC'),
                #                         as.POSIXct(79200, origin='2012-05-29', tz='UTC')),
                step=300, timezone='+0000')
  }) 
  
  output$display <- renderPlot ({
    if (is.null(input$times[1])) {return ()}
    input$PlotVar
    Project <- input$Project
    VRPlot <- VRP ()
    print ('entered display')
    # VRPlot <<- VRPlot
    Data <- data()
    SE <- getStartEnd (Data$Time)
    i <- getIndex (Data$Time, SE[1])
    FigFooter=sprintf("%s RF%02d %s %s-%s UTC,",Project,input$Flight,strftime(Data$Time[i], format="%Y-%m-%d", tz='UTC'),strftime(Data$Time[i], format="%H:%M:%S", tz='UTC'),strftime(Data$Time[getIndex(Data$Time,SE[2])], format="%H:%M:%S", tz='UTC'))
    FigDatestr=strftime(Sys.time(), format="%Y-%m-%d %H:%M:%S %Z")
    AddFooter <<- function() {
      CallingFunction <- sub ("\\(.*\\)", "", deparse (sys.call (-1)))
      mtext(paste(FigFooter,'generated by ', CallingFunction, 
                  FigDatestr),1,outer=T,cex=0.75)
    }
    
    namesV <- names(Data)
    namesV <- namesV[namesV != "Time"]
    for (n in namesV) {
      Data[!is.na(Data[ ,n]) & (abs(Data[,n]+32767) < 1), n] <- NA
    }
    Data <- Data[(Data$Time > input$times[1]) & (Data$Time < input$times[2]), ]
    DataV <- Data
    # DataV <- Data[setRange(Data$Time, StartTime, EndTime), ]
    namesV <- names(DataV)
    namesV <- namesV[namesV != "Time"]
    t <- !is.na (DataV$TASX) & (DataV$TASX < 110)
    DataV[t, namesV] <- NA
    ## guard against inf. VCSEL limits, as for rf08
    if (min(DataV$DP_VXL, na.rm=TRUE) == Inf) {
      DataV$DP_VXL <- rep(0, nrow(DataV))
    }
    if (min(DataV$DP_DPR, na.rm=TRUE) == Inf) {
      DataV$DP_DPR <- rep(0, nrow(DataV))
    }
    if (min(DataV$DP_DPL, na.rm=TRUE) == Inf) {
      DataV$DP_DPL <- rep(0, nrow(DataV))
    }
    DataV$DPXC[DataV$DPXC < -1000] <- NA
    if (psq[1, input$plot] %in% c(20, 22, 23)) {
      t1 <- input$times[1]
      # print (class(t1))
      t <- as.POSIXlt (t1)
      # print (class(t))
      StartTime <<- as.integer (10000*t$hour+100*t$min+t$sec)
      # print (StartTime)
    }
    eval(parse(text=sprintf("RPlot%d(Data, Seq=%d)", 
                            psq[1, input$plot], psq[2, input$plot])))
    print ('finished display')
  }, width=920, height=680)
  
  output$stats <- renderDataTable ({
    print ('entered stats')
    Ds <- data ()[, c('Time', slp[[psq[1,input$plot]]])]
    Ds <- Ds[(Ds$Time > input$times[1]) & (Ds$Time < input$times[2]), ]
    Dstats <- data.frame ()
    Dstats['Time', 1] <- 'Time'
    Dstats['Time', 2] <- NA
    Dstats['Time', 3] <- NA
    Dstats['Time', 4] <- formatTime (Ds$Time[1])
    Dstats['Time', 5] <- formatTime (Ds$Time[nrow(Ds)])
    for (nm in names(Ds)) {
      if (nm == 'Time') {next}
      Dstats[nm, 1] <- nm
      Dstats[nm, 2] <- mean (Ds[, nm], na.rm=TRUE)
      Dstats[nm, 3]   <- sd   (Ds[, nm], na.rm=TRUE)
      Dstats[nm, 4]  <- min  (Ds[, nm], na.rm=TRUE)
      Dstats[nm, 5]  <- max  (Ds[, nm], na.rm=TRUE)
    }
    names(Dstats) <- c('variable', 'mean', 'sd', 'min', 'max')
    row.names (Dstats) <- names(Ds)
    # Dstats[2:nrow(Dstats), 2:5] <- format(Dstats[2:nrow(Dstats),2:5], digits=5, scientific=FALSE)
    for (k in 2:5) {
      Dstats[2:nrow(Dstats), k] <- sprintf('%.3f', as.numeric(Dstats[2:nrow(Dstats), k]))
    }
    Dstats
  }, options=list(paging=FALSE, searching=FALSE))
  
  output$listing <- renderDataTable ({
    print ('entered listing')
    Ds <- data ()[, c('Time', slp[[psq[1,input$plot]]])]
    Ds <- Ds[(Ds$Time > input$times[1]) & (Ds$Time < input$times[2]), ]
    Ds
  }, options=list(paging=TRUE, searching=TRUE))
}



